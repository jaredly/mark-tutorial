;; Analyzed by ClojureScript 1.7.58
{:use-macros nil, :excludes #{}, :name replumb.load, :imports nil, :requires {cljs cljs.js, cljs.js cljs.js, string clojure.string, clojure.string clojure.string, common replumb.common, replumb.common replumb.common}, :uses nil, :defs {fake-load-fn! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :line 6, :column 7, :end-line 6, :end-column 20, :arglists (quote ([_ cb])), :doc "This load function just calls:\n  (cb {:lang   :js\n       :source \"\"})"}, :name replumb.load/fake-load-fn!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :end-column 20, :method-params ([_ cb]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6, :end-line 6, :max-fixed-arity 2, :fn-var true, :arglists (quote ([_ cb])), :doc "This load function just calls:\n  (cb {:lang   :js\n       :source \"\"})"}, no-resource-load-fn! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :line 14, :column 7, :end-line 14, :end-column 27, :arglists (quote ([_ cb])), :doc "Mimics \"Resource not found\" as it just calls: (cb nil)"}, :name replumb.load/no-resource-load-fn!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :end-column 27, :method-params ([_ cb]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 14, :end-line 14, :max-fixed-arity 2, :fn-var true, :arglists (quote ([_ cb])), :doc "Mimics \"Resource not found\" as it just calls: (cb nil)"}, filename->lang {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :line 19, :column 7, :end-line 19, :end-column 21, :arglists (quote ([file-name])), :doc "Converts a filename to a lang keyword by inspecting the file\n  extension."}, :name replumb.load/filename->lang, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :end-column 21, :method-params ([file-name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 19, :end-line 19, :max-fixed-arity 1, :fn-var true, :arglists (quote ([file-name])), :doc "Converts a filename to a lang keyword by inspecting the file\n  extension."}, extensions {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :line 25, :column 7, :end-line 25, :end-column 17, :arglists (quote ([] [macros])), :doc "Returns the correct file extensions to try (no dot prefix), following\n  the cljs.js/*load-fn* docstring.", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [macros]), :arglists ([] [macros]), :arglists-meta (nil nil)}}, :name replumb.load/extensions, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [macros]), :arglists ([] [macros]), :arglists-meta (nil nil)}, :method-params ([] [macros]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 25, :end-line 25, :max-fixed-arity 1, :fn-var true, :arglists ([] [macros]), :doc "Returns the correct file extensions to try (no dot prefix), following\n  the cljs.js/*load-fn* docstring."}, read-files-and-callback! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :line 33, :column 7, :end-line 33, :end-column 31, :arglists (quote ([verbose? file-names read-file-fn! load-fn-cb])), :doc "Loop on the file-names using a supplied read-file-fn (fn [file-name\n  src-cb] ...), calling back cb upon first successful read, otherwise\n  calling back with nil.\n  This function does not check whether parameters are nil, please do it\n  in the caller."}, :name replumb.load/read-files-and-callback!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :end-column 31, :method-params ([verbose? file-names read-file-fn! load-fn-cb]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 33, :end-line 33, :max-fixed-arity 4, :fn-var true, :arglists (quote ([verbose? file-names read-file-fn! load-fn-cb])), :doc "Loop on the file-names using a supplied read-file-fn (fn [file-name\n  src-cb] ...), calling back cb upon first successful read, otherwise\n  calling back with nil.\n  This function does not check whether parameters are nil, please do it\n  in the caller."}, file-paths {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :line 54, :column 7, :end-line 54, :end-column 17, :arglists (quote ([src-paths file-path])), :doc "Produces a sequence of file paths based on src-paths and file-path (a\n  path already including one or more \"/\" and an extension)."}, :name replumb.load/file-paths, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :end-column 17, :method-params ([src-paths file-path]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 54, :end-line 54, :max-fixed-arity 2, :fn-var true, :arglists (quote ([src-paths file-path])), :doc "Produces a sequence of file paths based on src-paths and file-path (a\n  path already including one or more \"/\" and an extension)."}, file-paths-for-load-fn {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :line 61, :column 7, :end-line 61, :end-column 29, :arglists (quote ([src-paths macros file-path-without-ext])), :doc "Produces a sequence of file names to try reading from src-paths and\n  file-path-without-ext (it should already include one or more\n  \"/\"). The right order and extension is taken from cljs.js/*load-fn*\n  docstring and takes into consideration the macros parameter."}, :name replumb.load/file-paths-for-load-fn, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :end-column 29, :method-params ([src-paths macros file-path-without-ext]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 61, :end-line 61, :max-fixed-arity 3, :fn-var true, :arglists (quote ([src-paths macros file-path-without-ext])), :doc "Produces a sequence of file names to try reading from src-paths and\n  file-path-without-ext (it should already include one or more\n  \"/\"). The right order and extension is taken from cljs.js/*load-fn*\n  docstring and takes into consideration the macros parameter."}, file-paths-for-closure {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :line 71, :column 7, :end-line 71, :end-column 29, :arglists (quote ([src-paths goog-path])), :doc "Produces a sequence of filenames to try reading crafted for goog\n  libraries, in the order they should be tried."}, :name replumb.load/file-paths-for-closure, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :end-column 29, :method-params ([src-paths goog-path]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 71, :end-line 71, :max-fixed-arity 2, :fn-var true, :arglists (quote ([src-paths goog-path])), :doc "Produces a sequence of filenames to try reading crafted for goog\n  libraries, in the order they should be tried."}, skip-load? {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :line 78, :column 7, :end-line 78, :end-column 17, :arglists (quote ([{:keys [name macros]}]))}, :name replumb.load/skip-load?, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/mark/qmh/jskkxn/out/replumb/load.cljs", :end-column 17, :method-params ([p__13676]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 78, :end-line 78, :max-fixed-arity 1, :fn-var true, :arglists (quote ([{:keys [name macros]}]))}}, :require-macros {cljs cljs.js, cljs.js cljs.js}, :cljs.analyzer/constants {:seen #{:js :macros :name cljs.core cljs.test :source :lang cljs.pprint cljs.analyzer :clj clojure.template}, :order [:lang :source :js :clj :name :macros cljs.core cljs.analyzer cljs.pprint cljs.test clojure.template]}, :doc nil}